// code-runner.js
const WebSocket = require('ws');
const { spawn } = require('child_process');
const fs = require('fs').promises;
const fsSync = require('fs');
const path = require('path');
const os = require('os');
const crypto = require('crypto');

// Input marker for interactive programs
const INPUT_MARKER = 'INPUT';

// Server configuration
const SERVER_CONFIG = {
  maxConcurrentExecutions: 10,
  executionTimeout: 30000, // 30 seconds
  maxQueueSize: 100,
  maxMemoryUsage: 512 * 1024 * 1024, // 512MB
  heartbeatInterval: 30000,
  cleanupInterval: 60000
};

// SafeQueue implementation (kept as class for queue management)
class SafeQueue {
  constructor(maxSize = 100) {
    this.queue = [];
    this.maxSize = maxSize;
  }

  enqueue(item) {
    if (this.queue.length >= this.maxSize) {
      throw new Error('Queue is full');
    }
    this.queue.push(item);
  }

  dequeue() {
    return this.queue.shift();
  }

  isEmpty() {
    return this.queue.length === 0;
  }

  size() {
    return this.queue.length;
  }

  clear() {
    this.queue = [];
  }
}

// ExecutionLimiter implementation (kept as class for limiter management)
class ExecutionLimiter {
  constructor(maxConcurrent = 10) {
    this.maxConcurrent = maxConcurrent;
    this.activeCount = 0;
    this.waitingQueue = new SafeQueue();
  }

  async acquire() {
    return new Promise((resolve, reject) => {
      if (this.activeCount < this.maxConcurrent) {
        this.activeCount++;
        resolve();
      } else {
        try {
          this.waitingQueue.enqueue({ resolve, reject });
        } catch (error) {
          reject(new Error('Execution queue is full'));
        }
      }
    });
  }

  release() {
    this.activeCount--;
    if (!this.waitingQueue.isEmpty()) {
      const { resolve } = this.waitingQueue.dequeue();
      this.activeCount++;
      resolve();
    }
  }

  getStats() {
    return {
      active: this.activeCount,
      waiting: this.waitingQueue.size(),
      maxConcurrent: this.maxConcurrent
    };
  }
}

// Module-level state
let clients = new Map();
let tempDirs = new Set();
let executionLimiter = new ExecutionLimiter(SERVER_CONFIG.maxConcurrentExecutions);
let cleanupInterval = null;
let isShuttingDown = false;
let wss = null;

// Utility functions (converted from class methods)

// Remove directory
async function removeDirectory(dirPath) {
  try {
    const files = await fs.readdir(dirPath);
    for (const file of files) {
      const filePath = path.join(dirPath, file);
      const stat = await fs.lstat(filePath);
      if (stat.isDirectory()) {
        await removeDirectory(filePath);
      } else {
        await fs.unlink(filePath);
      }
    }
    await fs.rmdir(dirPath);
  } catch (error) {
    // Silent directory removal errors
  }
}

// Generate client ID
function generateClientId(ws, req) {
  const remoteAddress = req.socket.remoteAddress || 'unknown';
  const remotePort = req.socket.remotePort || 0;
  const timestamp = Date.now();
  const random = crypto.randomBytes(8).toString('hex');
  return `${remoteAddress}:${remotePort}:${timestamp}:${random}`;
}

// Setup heartbeat for a client
function setupHeartbeat(clientId) {
  const client = clients.get(clientId);
  if (!client) return;

  const heartbeatInterval = setInterval(async () => {
    try {
      const client = clients.get(clientId);
      if (!client || client.websocket.readyState !== WebSocket.OPEN) {
        clearInterval(heartbeatInterval);
        return;
      }

      // Check for inactive clients
      if (Date.now() - client.lastActivity > SERVER_CONFIG.heartbeatInterval * 3) {
        clearInterval(heartbeatInterval);
        await cleanupClient(clientId);
        return;
      }

      await sendMessage(clientId, { type: 'ping' });
    } catch (error) {
      clearInterval(heartbeatInterval);
      await cleanupClient(clientId);
    }
  }, SERVER_CONFIG.heartbeatInterval);
}

// Handle message
async function handleMessage(clientId, data) {
  try {
    const client = clients.get(clientId);
    if (!client) return;

    client.lastActivity = Date.now();

    let message;
    try {
      message = JSON.parse(data.toString());
    } catch (error) {
      return; // Ignore invalid JSON
    }

    switch (message.type) {
      case 'run_code':
        await runCode(clientId, message.code, message.language || 'python');
        break;
      case 'input_response':
        handleInputResponse(clientId, message.input);
        break;
      case 'stop_execution':
        await stopExecution(clientId);
        break;
      case 'pong':
        // Heartbeat response
        break;
      default:
        // Ignore unknown message types
        break;
    }
  } catch (error) {
    // Silent error handling for message processing
  }
}

// Handle input response
function handleInputResponse(clientId, input) {
  try {
    const client = clients.get(clientId);
    if (!client) return;

    client.inputQueue.enqueue(input);
  } catch (error) {
    // Queue is full or other error
  }
}

// Run code (main dispatcher)
async function runCode(clientId, code, language = 'python') {
  let executionAcquired = false;
  try {
    const client = clients.get(clientId);
    if (!client) return;

    // Stop any existing execution
    await stopExecution(clientId);

    if (!code.trim()) {
      await sendMessage(clientId, { type: 'error', message: 'No code provided' });
      return;
    }

    // Check execution limits
    const stats = executionLimiter.getStats();
    if (stats.waiting >= SERVER_CONFIG.maxQueueSize) {
      await sendMessage(clientId, { type: 'error', message: 'Server is overloaded. Please try again later.' });
      return;
    }

    // Acquire execution slot
    await executionLimiter.acquire();
    executionAcquired = true;

    client.executionCount++;
    // Rate limiting per client
    if (client.executionCount > 50) {
      await sendMessage(clientId, { type: 'error', message: 'Rate limit exceeded. Please reconnect.' });
      return;
    }

    // Dispatch to language-specific handlers
    const handlers = {
      'c': runCCode,
      'python': runPythonCode,
      'javascript': runJavaScriptCode,
      'node': runJavaScriptCode,
      'cpp': runCppCode,
      'c++': runCppCode,
      'java': runJavaCode,
      'csharp': runCSharpCode,
      'c#': runCSharpCode,
      'cs': runCSharpCode
    };

    const handler = handlers[language.toLowerCase()];
    if (handler) {
      await handler(clientId, code);
    } else {
      await sendMessage(clientId, { type: 'error', message: `Unsupported language: ${language}` });
    }
  } catch (error) {
    await sendMessage(clientId, { type: 'error', message: `Execution failed: ${error.message}` });
  } finally {
    if (executionAcquired) {
      executionLimiter.release();
    }
  }
}

// Language-specific input wrappers (as functions)
function getCInputWrapper() {
  return `
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

char* get_server_input(const char* prompt) {
  if (prompt != NULL && strlen(prompt) > 0) {
    printf("%s", prompt);
    fflush(stdout);
  }
  printf("${INPUT_MARKER}");
  fflush(stdout);
  char* line = malloc(1024);
  if (line == NULL) return NULL;
  if (fgets(line, 1024, stdin) != NULL) {
    size_t len = strlen(line);
    if (len > 0 && line[len-1] == '\\n') line[len-1] = '\\0';
    return line;
  }
  free(line);
  return NULL;
}

#undef scanf
#define scanf custom_scanf
int custom_scanf(const char* format, ...) {
  va_list args;
  va_start(args, format);
  char* input = get_server_input(NULL);
  if (!input) {
    va_end(args);
    return 0;
  }
  int result = vsscanf(input, format, args);
  free(input);
  va_end(args);
  return result;
}
  `;
}

function getPythonInputWrapper() {
  return `
import sys
import builtins

original_input = builtins.input
def custom_input(prompt=''):
  try:
    if prompt:
      sys.stdout.write(str(prompt))
      sys.stdout.flush()
    sys.stdout.write('${INPUT_MARKER}')
    sys.stdout.flush()
    line = sys.stdin.readline()
    return line.rstrip('\\n')
  except:
    return ''
builtins.input = custom_input
  `;
}

function getJavaInputWrapper() {
  return `
import java.io.*;
import java.util.*;

class InputHelper {
  private static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

  public static String getInput(String prompt) {
    try {
      if (prompt != null && !prompt.isEmpty()) {
        System.out.print(prompt);
        System.out.flush(); // Critical: Force immediate output
      }
      System.out.print("${INPUT_MARKER}");
      System.out.flush(); // Critical: Flush before waiting for input
      String line = reader.readLine();
      System.out.flush(); // Flush after receiving input
      return line != null ? line : "";
    } catch (Exception e) {
      return "";
    }
  }

  public static int getInt(String prompt) {
    try {
      String input = getInput(prompt).trim();
      return Integer.parseInt(input);
    } catch (Exception e) {
      return 0;
    }
  }
}

class Scanner {
  private boolean closed = false;

  public Scanner(java.io.InputStream source) {
    // Constructor that accepts System.in
  }

  public int nextInt() {
    int result = InputHelper.getInt("");
    System.out.flush(); // Ensure output synchronization
    return result;
  }

  public String nextLine() {
    String result = InputHelper.getInput("");
    System.out.flush(); // Ensure output synchronization
    return result;
  }

  public String next() {
    String line = InputHelper.getInput("");
    String[] parts = line.trim().split("\\\\s+");
    String result = parts.length > 0 ? parts[0] : "";
    System.out.flush(); // Ensure output synchronization
    return result;
  }

  public boolean hasNext() {
    return !closed;
  }

  public void close() {
    closed = true;
  }
}
  `;
}

function getCppInputWrapper() {
  return `
#include <iostream>
#include <string>
#include <sstream>
#include <cstdlib>

std::string get_cpp_input(const std::string& prompt) {
  try {
    if (!prompt.empty()) {
      std::cout << prompt << std::flush;
    }
    std::cout << "${INPUT_MARKER}" << std::flush;
    std::string line;
    std::getline(std::cin, line);
    return line;
  } catch (...) {
    return "";
  }
}

class CustomInputStream {
private:
  std::string current_input;
  std::istringstream stream;
public:
  CustomInputStream& operator>>(int& value) {
    try {
      current_input = get_cpp_input("");
      stream.clear();
      stream.str(current_input);
      stream >> value;
    } catch (...) {
      value = 0;
    }
    return *this;
  }

  CustomInputStream& operator>>(double& value) {
    try {
      current_input = get_cpp_input("");
      stream.clear();
      stream.str(current_input);
      stream >> value;
    } catch (...) {
      value = 0.0;
    }
    return *this;
  }

  CustomInputStream& operator>>(std::string& value) {
    try {
      value = get_cpp_input("");
    } catch (...) {
      value = "";
    }
    return *this;
  }
};

#define cin custom_cin_instance
CustomInputStream custom_cin_instance;
using namespace std;
  `;
}

function getJavaInputWrapper() {
  return `
import java.io.*;
import java.util.*;

class InputHelper {
  private static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

  public static String getInput(String prompt) {
    try {
      if (prompt != null && !prompt.isEmpty()) {
        System.out.print(prompt);
        System.out.flush();
      }
      System.out.print("${INPUT_MARKER}");
      System.out.flush();
      String line = reader.readLine();
      return line != null ? line : "";
    } catch (Exception e) {
      return "";
    }
  }

  public static int getInt(String prompt) {
    try {
      return Integer.parseInt(getInput(prompt).trim());
    } catch (Exception e) {
      return 0;
    }
  }

  public static double getDouble(String prompt) {
    try {
      return Double.parseDouble(getInput(prompt).trim());
    } catch (Exception e) {
      return 0.0;
    }
  }
}

class Scanner {
  private boolean closed = false;

  public Scanner(java.io.InputStream source) {
    // Constructor that accepts System.in
  }

  public int nextInt() {
    return InputHelper.getInt("");
  }

  public double nextDouble() {
    return InputHelper.getDouble("");
  }

  public String nextLine() {
    return InputHelper.getInput("");
  }

  public String next() {
    String line = InputHelper.getInput("");
    String[] parts = line.trim().split("\\s+");
    return parts.length > 0 ? parts[0] : "";
  }

  public boolean hasNext() {
    return !closed;
  }

  public void close() {
    closed = true;
  }
}
  `;
}

function getCSharpInputWrapper() {
  return `
using System;

public static class InputHelper {
  public static string GetInput(string prompt) {
    try {
      if (!string.IsNullOrEmpty(prompt)) {
        Console.Write(prompt);
      }
      Console.Write("${INPUT_MARKER}");
      return Console.ReadLine() ?? "";
    } catch {
      return "";
    }
  }

  public static int GetInt(string prompt) {
    try {
      return int.Parse(GetInput(prompt));
    } catch {
      return 0;
    }
  }

  public static double GetDouble(string prompt) {
    try {
      return double.Parse(GetInput(prompt));
    } catch {
      return 0.0;
    }
  }
}
  `;
}

// Language-specific run functions
async function runCCode(clientId, code) {
  try {
    const client = clients.get(clientId);
    if (!client) return;

    const { userIncludes, userCode } = extractImportsAndPackages(code, 'c');
    const fullCode = userIncludes.join('\n') + '\n' + getCInputWrapper() + '\n' + userCode;

    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'c-exec-'));
    tempDirs.add(tempDir);
    client.tempDirs.add(tempDir);

    const sourceFile = path.join(tempDir, 'main.c');
    const execFile = path.join(tempDir, process.platform === 'win32' ? 'main.exe' : 'main');

    await fs.writeFile(sourceFile, fullCode, 'utf8');

    // Compile
    const compileResult = await runCommand('gcc', [sourceFile, '-o', execFile, '-std=c99', '-lm'], { timeout: 30000, cwd: tempDir });
    if (compileResult.exitCode !== 0) {
      await sendMessage(clientId, { type: 'error_output', data: `C compilation error:\n${compileResult.stderr}` });
      return;
    }

    await sendMessage(clientId, { type: 'output', data: 'C compilation successful!' });

    await executeProgram(clientId, [execFile], { cwd: tempDir });
  } catch (error) {
    await sendMessage(clientId, { type: 'error', message: `C execution failed: ${error.message}` });
  }
}

async function runPythonCode(clientId, code) {
  try {
    const client = clients.get(clientId);
    if (!client) return;

    const fullCode = getPythonInputWrapper() + '\n' + code;

    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'py-exec-'));
    tempDirs.add(tempDir);
    client.tempDirs.add(tempDir);

    const scriptFile = path.join(tempDir, 'main.py');
    await fs.writeFile(scriptFile, fullCode, 'utf8');

    await executeProgram(clientId, ['python', '-u', scriptFile], { cwd: tempDir });
  } catch (error) {
    await sendMessage(clientId, { type: 'error', message: `Python execution failed: ${error.message}` });
  }
}

async function runJavaScriptCode(clientId, code) {
  try {
    const client = clients.get(clientId);
    if (!client) return;

    let fullCode = code;
    if (code.includes("require('readline')") || code.includes('require("readline")')) {
      fullCode = getJavaScriptInputWrapper() + '\n' + code;
    }

    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'js-exec-'));
    tempDirs.add(tempDir);
    client.tempDirs.add(tempDir);

    const scriptFile = path.join(tempDir, 'main.js');
    await fs.writeFile(scriptFile, fullCode, 'utf8');

    await executeProgram(clientId, ['node', scriptFile], { cwd: tempDir });
  } catch (error) {
    await sendMessage(clientId, { type: 'error', message: `JavaScript execution failed: ${error.message}` });
  }
}

async function runCppCode(clientId, code) {
  try {
    const client = clients.get(clientId);
    if (!client) return;

    const { userIncludes, userCode } = extractImportsAndPackages(code, 'cpp');
    const fullCode = userIncludes.join('\n') + '\n' + getCppInputWrapper() + '\n' + userCode;

    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'cpp-exec-'));
    tempDirs.add(tempDir);
    client.tempDirs.add(tempDir);

    const sourceFile = path.join(tempDir, 'main.cpp');
    const execFile = path.join(tempDir, process.platform === 'win32' ? 'main.exe' : 'main');

    await fs.writeFile(sourceFile, fullCode, 'utf8');

    // Compile
    const compileResult = await runCommand('g++', [sourceFile, '-o', execFile, '-std=c++17', '-lm'], { timeout: 30000, cwd: tempDir });
    if (compileResult.exitCode !== 0) {
      await sendMessage(clientId, { type: 'error_output', data: `C++ compilation error:\n${compileResult.stderr}` });
      return;
    }

    await sendMessage(clientId, { type: 'output', data: 'C++ compilation successful!' });

    await executeProgram(clientId, [execFile], { cwd: tempDir });
  } catch (error) {
    await sendMessage(clientId, { type: 'error', message: `C++ execution failed: ${error.message}` });
  }
}

async function runJavaCode(clientId, code) {
  try {
    const client = clients.get(clientId);
    if (!client) return;

    const { userImports, userCode } = extractImportsAndPackages(code, 'java');
    const className = extractJavaClassName(userCode);
    const wrapperCode = getJavaInputWrapper();
    const fullCode = userImports.join('\n') + '\n' + wrapperCode + '\n' + userCode;

    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'java-exec-'));
    tempDirs.add(tempDir);
    client.tempDirs.add(tempDir);

    const javaFile = path.join(tempDir, `${className}.java`);
    await fs.writeFile(javaFile, fullCode, 'utf8');

    // Compile
    const compileResult = await runCommand('javac', [javaFile], { timeout: 30000, cwd: tempDir });
    if (compileResult.exitCode !== 0) {
      await sendMessage(clientId, { type: 'error_output', data: `Java compilation error:\n${compileResult.stderr}` });
      return;
    }

    await sendMessage(clientId, { type: 'output', data: 'Java compilation successful!' });

    await executeProgram(clientId, ['java', '-cp', tempDir, className], { cwd: tempDir });
  } catch (error) {
    await sendMessage(clientId, { type: 'error', message: `Java execution failed: ${error.message}` });
  }
}

async function runCSharpCode(clientId, code) {
  try {
    const client = clients.get(clientId);
    if (!client) return;

    const { userUsings, userCode } = extractImportsAndPackages(code, 'csharp');
    const wrapperCode = getCSharpInputWrapper();
    const fullCode = userUsings.join('\n') + '\n' + wrapperCode + '\n' + userCode;

    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'cs-exec-'));
    tempDirs.add(tempDir);
    client.tempDirs.add(tempDir);

    // Create dotnet project
    await runCommand('dotnet', ['new', 'console', '-n', 'Runner', '--force'], { timeout: 30000, cwd: tempDir });

    const projectDir = path.join(tempDir, 'Runner');
    const programFile = path.join(projectDir, 'Program.cs');
    await fs.writeFile(programFile, fullCode, 'utf8');

    // Build
    const buildResult = await runCommand('dotnet', ['build'], { timeout: 30000, cwd: projectDir });
    if (buildResult.exitCode !== 0) {
      await sendMessage(clientId, { type: 'error_output', data: `C# build error:\n${buildResult.stderr}` });
      return;
    }

    await sendMessage(clientId, { type: 'output', data: 'C# compilation successful!' });

    await executeProgram(clientId, ['dotnet', 'run', '--no-build'], { cwd: projectDir });
  } catch (error) {
    await sendMessage(clientId, { type: 'error', message: `C# execution failed: ${error.message}` });
  }
}

// Extract imports and packages
function extractImportsAndPackages(code, language) {
  const lines = code.split('\n');
  const imports = [];
  const otherLines = [];

  if (language === 'java') {
    for (const line of lines) {
      const stripped = line.trim();
      if (stripped.startsWith('import ') || stripped.startsWith('package ')) {
        if (!stripped.includes('Scanner')) {
          imports.push(line);
        }
      } else {
        otherLines.push(line);
      }
    }
    return { userImports: imports, userCode: otherLines.join('\n') };
  } else if (language === 'c' || language === 'cpp') {
    for (const line of lines) {
      const stripped = line.trim();
      if (stripped.startsWith('#include') || stripped.startsWith('#define') || stripped.startsWith('#pragma')) {
        imports.push(line);
      } else {
        otherLines.push(line);
      }
    }
    return { userIncludes: imports, userCode: otherLines.join('\n') };
  } else if (language === 'csharp') {
    for (const line of lines) {
      const stripped = line.trim();
      if (stripped.startsWith('using ')) {
        imports.push(line);
      } else {
        otherLines.push(line);
      }
    }
    return { userUsings: imports, userCode: otherLines.join('\n') };
  }

  return { userCode: otherLines.join('\n') };
}

// Extract Java class name
function extractJavaClassName(code) {
  try {
    // Look for class with main method
    let match = code.match(/class\s+(\w+)\s*\{.*public\s+static\s+void\s+main/s);
    if (match) return match[1];

    // Look for any public class
    match = code.match(/public\s+class\s+(\w+)/);
    if (match) return match[1];

    // Look for any class
    match = code.match(/class\s+(\w+)/);
    if (match) return match[1];
  } catch (error) {
    // Silent error handling
  }
  return 'Main';
}

// Run command (for compilation)
async function runCommand(cmd, args, options = {}) {
  return new Promise((resolve, reject) => {
    const timeout = options.timeout || 30000;
    const proc = spawn(cmd, args, { cwd: options.cwd, stdio: ['pipe', 'pipe', 'pipe'] });

    let stdout = '';
    let stderr = '';
    let killed = false;

    const timer = setTimeout(() => {
      if (!killed) {
        killed = true;
        proc.kill('SIGKILL');
        reject(new Error('Command timeout'));
      }
    }, timeout);

    proc.stdout.on('data', (data) => { stdout += data.toString(); });
    proc.stderr.on('data', (data) => { stderr += data.toString(); });

    proc.on('close', (code) => {
      clearTimeout(timer);
      if (!killed) {
        resolve({ exitCode: code, stdout, stderr });
      }
    });

    proc.on('error', (error) => {
      clearTimeout(timer);
      if (!killed) {
        reject(error);
      }
    });
  });
}

// Execute program
async function executeProgram(clientId, cmd, options = {}) {
  try {
    const client = clients.get(clientId);
    if (!client) return;

    const proc = spawn(cmd[0], cmd.slice(1), {
      cwd: options.cwd,
      stdio: ['pipe', 'pipe', 'pipe'],
      env: { ...process.env, LANG: 'en_US.UTF-8', LC_ALL: 'en_US.UTF-8' }
    });

    client.process = proc;
    client.isRunning = true;

    // Set execution timeout
    const executionTimeout = setTimeout(async () => {
      if (client.isRunning) {
        await stopExecution(clientId);
        await sendMessage(clientId, { type: 'error', message: 'Execution timeout' });
      }
    }, SERVER_CONFIG.executionTimeout);

    // Handle process IO
    handleProcessIO(clientId, proc, executionTimeout);
  } catch (error) {
    await sendMessage(clientId, { type: 'error', message: `Failed to start process: ${error.message}` });
  }
}

// Handle process IO
function handleProcessIO(clientId, proc, executionTimeout) {
  const client = clients.get(clientId);
  if (!client) return;

  let outputBuffer = '';
  let errorBuffer = '';

  // Handle stdout
  proc.stdout.on('data', async (data) => {
    try {
      outputBuffer += data.toString();
      await processOutput(clientId, outputBuffer, 'output');
      outputBuffer = ''; // Clear buffer after processing
    } catch (error) {
      // Silent error handling
    }
  });

  // Handle stderr
  proc.stderr.on('data', async (data) => {
    try {
      errorBuffer += data.toString();
      await processOutput(clientId, errorBuffer, 'error_output');
      errorBuffer = ''; // Clear buffer after processing
    } catch (error) {
      // Silent error handling
    }
  });

  // Handle stdin input from client
  handleInput(clientId, proc);

  // Handle process completion
  proc.on('close', async (code) => {
    try {
      clearTimeout(executionTimeout);
      if (client.isRunning) {
        client.isRunning = false;
        await sendMessage(clientId, { type: 'execution_complete', exit_code: code || 0 });
        await cleanupProcess(clientId);
      }
    } catch (error) {
      // Silent error handling
    }
  });

  proc.on('error', async (error) => {
    try {
      clearTimeout(executionTimeout);
      client.isRunning = false;
      await sendMessage(clientId, { type: 'error', message: `Process error: ${error.message}` });
      await cleanupProcess(clientId);
    } catch (err) {
      // Silent error handling
    }
  });
}

// Process output
async function processOutput(clientId, buffer, type) {
  const lines = buffer.split('\n');
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.includes(INPUT_MARKER)) {
      const parts = line.split(INPUT_MARKER);
      // Send any output before the input marker
      if (parts[0]) {
        await sendMessage(clientId, { type, data: parts[0] });
      }
      // Request input from client
      await sendMessage(clientId, { type: 'input_request' });
      // Send any output after the input marker
      if (parts[1]) {
        await sendMessage(clientId, { type, data: parts[1] });
      }
    } else if (i < lines.length - 1 || line.trim()) {
      // Send complete lines or non-empty content
      await sendMessage(clientId, { type, data: line + (i < lines.length - 1 ? '\n' : '') });
    }
  }
}

// Handle input
function handleInput(clientId, proc) {
  const processInput = async () => {
    try {
      const client = clients.get(clientId);
      if (!client || !client.isRunning || !proc.stdin || proc.stdin.destroyed) return;

      if (!client.inputQueue.isEmpty()) {
        try {
          const input = client.inputQueue.dequeue() + '\n';
          proc.stdin.write(input);
        } catch (error) {
          // Input queue empty or write error
        }
      }

      // Continue processing input
      if (client.isRunning) {
        setTimeout(processInput, 100);
      }
    } catch (error) {
      // Silent error handling
    }
  };

  processInput();
}

// Stop execution
async function stopExecution(clientId) {
  try {
    const client = clients.get(clientId);
    if (!client) return;

    client.isRunning = false;

    if (client.process) {
      try {
        // Try graceful termination first
        if (!client.process.killed) {
          client.process.kill('SIGTERM');
        }

        // Wait for graceful termination
        await new Promise((resolve) => {
          const timeout = setTimeout(() => {
            if (!client.process.killed) {
              client.process.kill('SIGKILL');
            }
            resolve();
          }, 2000);

          client.process.on('close', () => {
            clearTimeout(timeout);
            resolve();
          });
        });
      } catch (error) {
        // Silent error handling
      }
    }

    await cleanupProcess(clientId);
  } catch (error) {
    // Silent error handling
  }
}

// Cleanup process
async function cleanupProcess(clientId) {
  try {
    const client = clients.get(clientId);
    if (!client) return;

    // Clear input queue
    client.inputQueue.clear();

    // Reset client state
    client.process = null;
    client.isRunning = false;

    // Clean up temporary directories
    for (const tempDir of client.tempDirs) {
      try {
        if (fsSync.existsSync(tempDir)) {
          await removeDirectory(tempDir);
          tempDirs.delete(tempDir);
        }
      } catch (error) {
        // Silent cleanup error
      }
    }
    client.tempDirs.clear();
  } catch (error) {
    // Silent error handling
  }
}

// Cleanup client
async function cleanupClient(clientId) {
  try {
    await stopExecution(clientId);
    clients.delete(clientId);
  } catch (error) {
    // Silent error handling
  }
}

// Send message
async function sendMessage(clientId, message) {
  try {
    const client = clients.get(clientId);
    if (!client) return false;

    const ws = client.websocket;
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
      return true;
    }
  } catch (error) {
    // Silent error handling
  }
  return false;
}

// Cleanup orphaned resources
async function cleanupOrphanedResources() {
  try {
    // Clean up temporary directories
    for (const tempDir of tempDirs) {
      try {
        if (fsSync.existsSync(tempDir)) {
          await removeDirectory(tempDir);
          tempDirs.delete(tempDir);
        }
      } catch (error) {
        // Silent cleanup failure
      }
    }

    // Clean up disconnected clients
    for (const [clientId, client] of clients) {
      if (client.websocket.readyState === WebSocket.CLOSED) {
        await cleanupClient(clientId);
      }
    }
  } catch (error) {
    // Silent cleanup errors
  }
}

// Setup cleanup interval
function setupCleanupInterval() {
  cleanupInterval = setInterval(cleanupOrphanedResources, SERVER_CONFIG.cleanupInterval);
}

// Handle connection
async function handleConnection(ws, req) {
  let clientId = null;
  try {
    clientId = generateClientId(ws, req);

    // Initialize client state
    clients.set(clientId, {
      websocket: ws,
      process: null,
      tempDirs: new Set(),
      inputQueue: new SafeQueue(),
      isRunning: false,
      lastActivity: Date.now(),
      executionCount: 0
    });

    // Send connection confirmation
    await sendMessage(clientId, {
      type: 'connection_established',
      message: 'Connected to multi-language execution server',
      clientId
    });

    // Set up WebSocket event handlers
    ws.on('message', async (data) => {
      try {
        await handleMessage(clientId, data);
      } catch (error) {
        await sendMessage(clientId, { type: 'error', message: 'Failed to process message' });
      }
    });

    ws.on('close', async () => {
      await cleanupClient(clientId);
    });

    ws.on('error', async (error) => {
      await cleanupClient(clientId);
    });

    // Set up heartbeat
    setupHeartbeat(clientId);
  } catch (error) {
    if (clientId) {
      await cleanupClient(clientId);
    }
  }
}

// Graceful shutdown
async function gracefulShutdown() {
  if (isShuttingDown) return;
  isShuttingDown = true;

  console.log('Shutting down server...');

  try {
    // Clear cleanup interval
    if (cleanupInterval) {
      clearInterval(cleanupInterval);
    }

    // Stop accepting new connections
    if (wss) {
      wss.close();
    }

    // Cleanup all clients
    const cleanupPromises = Array.from(clients.keys()).map(clientId => cleanupClient(clientId));
    await Promise.all(cleanupPromises);

    // Cleanup temporary directories
    const tempCleanupPromises = Array.from(tempDirs).map(tempDir => removeDirectory(tempDir));
    await Promise.all(tempCleanupPromises);

    console.log('Server shutdown complete');
  } catch (error) {
    console.error('Error during shutdown:', error);
  }

  process.exit(0);
}

// Handle uncaught exceptions and rejections
function handleUncaughtException(error) {
  console.error('Uncaught Exception:', error);
  if (!isShuttingDown) {
    gracefulShutdown();
  }
}

function handleUnhandledRejection(reason, promise) {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
}

// Initialize socket server (main export)
function initializeSocketServer(httpServer) {
  // Reset state if needed
  clients = new Map();
  tempDirs = new Set();
  executionLimiter = new ExecutionLimiter(SERVER_CONFIG.maxConcurrentExecutions);
  cleanupInterval = null;
  isShuttingDown = false;

  // Create WebSocket server attached to the provided HTTP server
  wss = new WebSocket.Server({
    server: httpServer,
    perMessageDeflate: false,
    maxPayload: 1024 * 1024 // 1MB max message size
  });

  wss.on('connection', handleConnection);

  wss.on('error', (error) => {
    console.error('WebSocket server error:', error);
  });

  // Setup cleanup interval
  setupCleanupInterval();

  // Handle process termination
  process.on('SIGINT', gracefulShutdown);
  process.on('SIGTERM', gracefulShutdown);
  process.on('uncaughtException', handleUncaughtException);
  process.on('unhandledRejection', handleUnhandledRejection);

  console.log('Multi-language execution server initialized');
  console.log('Supported languages: Python, JavaScript, C, C++, Java, C#');
  console.log('Connect from your web interface to start executing code.');
}

module.exports = { initializeSocketServer };
